The updater script
==================

When this script is run, it downloads list of packages and upgrades the system
based on the list.

It can handle lists of packages individual to the given device and individual
encrypted packages.

The URL of the repository and of the package list is hardcoded at the top of
the script.

The repository layout
---------------------

Assume that `$ID` is the serial number of the device in question. The
`$BASE_URL` is the top level of the repository structure.

The list for the device is located as `$BASE_URL/lists/$ID`. If that one does
not exist, the updater script takes a generic one, at
`$BASE_URL/lists/generic`.

An unencrypted package is located at address
`$BASE_URL/packages/<packagename>-<packageversion>.ipk`. An encrypted one is at
`$BASE_URL/packages/<packagename>-<packageversion>-$ID.ipk`.

Note that the repository may contain packages in multiple versions.

The package list format
-----------------------

Each line represents one package. The format of the line is:

  <package-name>	<version>	<flags>

The columns are separated by one tab. The version is the version that should be
installed on the device.

Flags represent special properties of the package. Each one is an on-off
switch. Each flag is single letter, all of them are concatenated together.

E::
  The package is encrypted and individual for the given device.
R::
  Instead of installing the package, the package should be removed from the
  system. The version should be `-` in this case.
F::
  Force re-installation even if it is in current version.
C::
  Do a cooldown sleep after installing or removing this package.
U::
  Request a restart of updater. After installing the package, start updater
  from the beginning.
I::
  Update the package only if already installed. Do not install if not installed
  yet. Used for upgrading packages that need exact version if they are installed,
  but not crucial for working of the device, like kernel modules.
X::
  The name is not a name of package directly, but a regular expression. All packages
  matching it will be included with the same flags.
<number>::
  Packages with lower number are considered sooner when planning the order.
  Packages without number are left as last.

Dependencies
------------

Dependencies are not considered on the device. The list is processed from top
to bottom, one line at a time. If one package depends on another, it should be
listed in the list above the another.

Example
-------

This is an example of the package list that includes ucollect with its all
dependencies and removes nuci.

  libgcc	4.6-linaro-1	
  libc	0.9.33.2-1	
  libpcap	1.1.1-2	
  libpthread	0.9.33.2-1	
  librt	0.9.33.2-1	
  libopenssl	1.0.1e-1	
  zlib	1.2.7-1
  libuci	2013-05-02.1-1	
  ucollect	14	E
  nuci	-	R

The generator script
====================

The generator script can generate the list of packages and the directory with
the package archives.

To run it, pass the base URL of the openWRT repository to generate the packages
from. Then, pass the list of desired packages to its standard input, one
package per line. A package name can be followed by flags. There's another flag
in addition to the ones in package list, `1`. If it is present, the operation
is placed at the top of the list (it is implemented for removal only now).

The generator tracks dependencies and includes them in the final list.

It is integrated into jenkins, so the basic list is regenerated automatically.
The list of packages is in the `list-desired` files.

The deployment script
=====================

There are currently 3 stages of stability of the OpenWRT repository. The first
(most unstable) is in the `test` branch. Whenever a new version is pushed,
Jenkinst builds the basic set of packages and generates updates for them. These
are installed on few devices close at hand.

The second stage is in the branch `master`. It acts mostly the same, except that:

 * All available packages are built.
 * The updates are installed on few other devices that are not necessarily as
   close at hand.

The last deployment is done by copying what was previously built for the
`master` branch, after enough testing. To ensure integration into the rest of
the deployment process and to protect against deploying untested versions
without due testing, the following needs to be done:

 1. The hash of the tested commit on `master` branch is entered into the
    `deploy` file and a Signed-Off-By line is added by whoever adds the hash.
    Note that this is the hash in the commit in openWRT repository, inserted
    into file in the `misc` repository.

 2. This commit is pushed into special branch `pending`.
 3. Another person pulls that branch and (after checking the changes brought by
    such revision) adds their own Signed-Off-By line by:

	git commit --amend -s

 4. After that, the checker force-pushes to the `pending` branch and overwrites
    the commit by its current version:

	git push -f

 5. A third person signs the commit by a PGP key trusted by the jenkins build:

	git pull
	git commit --amend -S<keyid> # Note the capital S

 6. Merges the modified commit into master and pushes.
 7. Launches the `Deploy` job in Jeknins (it must be started manually).

[NOTE]
The commit which hash is in the `deploy` file must still be on the HEAD of the
`master` branch. If a newer has been pushed in between, the deploy won't work,
because it just copies the already compiled files.
